
@{
    Layout = null;
}

<script type="text/javascript">
    @*


//Requiere Jquery Easing 1.3
// Generated by CoffeeScript 1.10.0
/** preserve OverlappingMarkerSpiderfier
https://github.com/jawj/OverlappingMarkerSpiderfier
Copyright (c) 2011 - 2013 George MacKerron
Released under the MIT licence: http://opensource.org/licenses/mit-license
Note: The Google Maps API v3 must be included *before* this code
*/

(function() {
  var ref,
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  if (((ref = this['google']) != null ? ref['maps'] : void 0) == null) {
    return;
  }

  this['OverlappingMarkerSpiderfier'] = (function() {
    var ge, gm, j, lcH, lcU, len, mt, nonspMarkers, p, ref1, spMarkers, twoPi, x;

    p = _Class.prototype;

    ref1 = [_Class, p];
    for (j = 0, len = ref1.length; j < len; j++) {
      x = ref1[j];
      x['VERSION'] = '0.3.3';
    }

    gm = google.maps;

    ge = gm.event;

    mt = gm.MapTypeId;

    twoPi = Math.PI * 2;

    spMarkers = [];

    nonspMarkers = [];

    p['keepSpiderfied'] = false;

    p['markersWontHide'] = false;

    p['markersWontMove'] = false;

    p['nearbyDistance'] = 20;

    p['circleSpiralSwitchover'] = 9;

    p['circleFootSeparation'] = 23;

    p['circleStartAngle'] = twoPi / 12;

    p['spiralFootSeparation'] = 26;

    p['spiralLengthStart'] = 11;

    p['spiralLengthFactor'] = 4;

    p['spiderfiedZIndex'] = 1000;

    p['usualLegZIndex'] = 10;

    p['highlightedLegZIndex'] = 20;

    p['legWeight'] = 1.5;

    p['legColors'] = {
      'usual': {},
      'highlighted': {}
    };

    lcU = p['legColors']['usual'];

    lcH = p['legColors']['highlighted'];

    lcU[mt.HYBRID] = lcU[mt.SATELLITE] = '#fff';

    lcH[mt.HYBRID] = lcH[mt.SATELLITE] = '#f00';

    lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = '#444';

    lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = '#f00';

    function _Class(map1, opts) {
      var e, k, l, len1, ref2, v;
      this.map = map1;
      if (opts == null) {
        opts = {};
      }
      for (k in opts) {
        if (!hasProp.call(opts, k)) continue;
        v = opts[k];
        this[k] = v;
      }
      this.projHelper = new this.constructor.ProjHelper(this.map);
      this.initMarkerArrays();
      this.listeners = {};
      ref2 = ['click', 'zoom_changed', 'maptypeid_changed'];
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        e = ref2[l];
        ge.addListener(this.map, e, (function(_this) {
          return function() {
            return _this['unspiderfy']();
          };
        })(this));
        ge.addListener(this.map, e, (function(_this) {
          return function() {
            return _this.clearSpArrays();
          };
        })(this));
      }
    }

    p.initMarkerArrays = function() {
      this.markers = [];
      return this.markerListenerRefs = [];
    };

    p.clearSpArrays = function() {
      spMarkers = [];
      return nonspMarkers = [];
    };

    p['addMarker'] = function(marker) {
      var listenerRefs;
      if (marker['_oms'] != null) {
        return this;
      }
      marker['_oms'] = true;
      listenerRefs = [
        ge.addListener(marker, 'click', (function(_this) {
          return function(event) {
            return _this.spiderListener(marker, event);
          };
        })(this))
      ];
      if (!this['markersWontHide']) {
        listenerRefs.push(ge.addListener(marker, 'visible_changed', (function(_this) {
          return function() {
            return _this.markerChangeListener(marker, false);
          };
        })(this)));
      }
      if (!this['markersWontMove']) {
        listenerRefs.push(ge.addListener(marker, 'ghostposition_changed', (function(_this) {
          return function() {
            return _this.markerChangeListener(marker, true);
          };
        })(this)));
      }
      this.markerListenerRefs.push(listenerRefs);
      this.markers.push(marker);
      return this;
    };

    p['keepItSpiderfied'] = function() {
      return this.spiderfy(spMarkers, nonspMarkers);
    };

    p.markerChangeListener = function(marker, positionChanged) {
      if ((marker['_omsData'] != null) && (positionChanged || !marker.getVisible()) && !((this.spiderfying != null) || (this.unspiderfying != null))) {
        return this['unspiderfy'](positionChanged ? marker : null);
      }
    };

    p['getMarkers'] = function() {
      return this.markers.slice(0);
    };

    p['removeMarker'] = function(marker) {
      var i, l, len1, listenerRef, listenerRefs;
      if (marker['_omsData'] != null) {
        this['unspiderfy']();
      }
      i = this.arrIndexOf(this.markers, marker);
      if (i < 0) {
        return this;
      }
      listenerRefs = this.markerListenerRefs.splice(i, 1)[0];
      for (l = 0, len1 = listenerRefs.length; l < len1; l++) {
        listenerRef = listenerRefs[l];
        ge.removeListener(listenerRef);
      }
      delete marker['_oms'];
      this.markers.splice(i, 1);
      return this;
    };

    p['clearMarkers'] = function() {
      var i, l, len1, len2, listenerRef, listenerRefs, marker, n, ref2;
      this['unspiderfy']();
      ref2 = this.markers;
      for (i = l = 0, len1 = ref2.length; l < len1; i = ++l) {
        marker = ref2[i];
        listenerRefs = this.markerListenerRefs[i];
        for (n = 0, len2 = listenerRefs.length; n < len2; n++) {
          listenerRef = listenerRefs[n];
          ge.removeListener(listenerRef);
        }
        delete marker['_oms'];
      }
      this.initMarkerArrays();
      return this;
    };

    p['addListener'] = function(event, func) {
      var base;
      ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);
      return this;
    };

    p['removeListener'] = function(event, func) {
      var i;
      i = this.arrIndexOf(this.listeners[event], func);
      if (!(i < 0)) {
        this.listeners[event].splice(i, 1);
      }
      return this;
    };

    p['clearListeners'] = function(event) {
      this.listeners[event] = [];
      return this;
    };

    p.trigger = function() {
      var args, event, func, l, len1, ref2, ref3, results;
      event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      ref3 = (ref2 = this.listeners[event]) != null ? ref2 : [];
      results = [];
      for (l = 0, len1 = ref3.length; l < len1; l++) {
        func = ref3[l];
        results.push(func.apply(null, args));
      }
      return results;
    };

    p.generatePtsCircle = function(count, centerPt) {
      var angle, angleStep, circumference, i, l, legLength, ref2, results;
      circumference = this['circleFootSeparation'] * (2 + count);
      legLength = circumference / twoPi;
      angleStep = twoPi / count;
      results = [];
      for (i = l = 0, ref2 = count; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        angle = this['circleStartAngle'] + i * angleStep;
        results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));
      }
      return results;
    };

    p.generatePtsSpiral = function(count, centerPt) {
      var angle, i, l, legLength, pt, ref2, results;
      legLength = this['spiralLengthStart'];
      angle = 0;
      results = [];
      for (i = l = 0, ref2 = count; 0 <= ref2 ? l < ref2 : l > ref2; i = 0 <= ref2 ? ++l : --l) {
        angle += this['spiralFootSeparation'] / legLength + i * 0.0005;
        pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));
        legLength += twoPi * this['spiralLengthFactor'] / angle;
        results.push(pt);
      }
      return results;
    };

    p.spiderListener = function(marker, event) {
      var l, len1, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, ref2;
      markerSpiderfied = marker['_omsData'] != null;
      if (!(markerSpiderfied && this['keepSpiderfied'])) {
        this['unspiderfy']();
      }
      if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === 'GoogleEarthAPI') {
        return this.trigger('click', marker, event);
      } else {
        nearbyMarkerData = [];
        nonNearbyMarkers = [];
        nDist = this['nearbyDistance'];
        pxSq = nDist * nDist;
        markerPt = this.llToPt(marker.getGhostPosition());
        ref2 = this.markers;
        for (l = 0, len1 = ref2.length; l < len1; l++) {
          m = ref2[l];
          if (!((m.map != null) && m.getVisible())) {
            continue;
          }
          mPt = this.llToPt(m.getGhostPosition());
          if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
            nearbyMarkerData.push({
              marker: m,
              markerPt: mPt
            });
          } else {
            nonNearbyMarkers.push(m);
          }
        }
        if (nearbyMarkerData.length === 1) {
          return this.trigger('click', marker, event);
        } else {
          return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);
        }
      }
    };

    p['markersNearMarker'] = function(marker, firstOnly) {
      var l, len1, m, mPt, markerPt, markers, nDist, pxSq, ref2, ref3, ref4;
      if (firstOnly == null) {
        firstOnly = false;
      }
      if (this.projHelper.getProjection() == null) {
        throw "Must wait for 'idle' event on map before calling markersNearMarker";
      }
      nDist = this['nearbyDistance'];
      pxSq = nDist * nDist;
      markerPt = this.llToPt(marker.getGhostPosition());
      markers = [];
      ref2 = this.markers;
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        m = ref2[l];
        if (m === marker || (m.map == null) || !m.getVisible()) {
          continue;
        }
        mPt = this.llToPt((ref3 = (ref4 = m['_omsData']) != null ? ref4.usualPosition : void 0) != null ? ref3 : m.getGhostPosition());
        if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
          markers.push(m);
          if (firstOnly) {
            break;
          }
        }
      }
      return markers;
    };

    p['markersNearAnyOtherMarker'] = function() {
      var i, i1, i2, l, len1, len2, len3, m, m1, m1Data, m2, m2Data, mData, n, nDist, pxSq, q, ref2, ref3, ref4, results;
      if (this.projHelper.getProjection() == null) {
        throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker";
      }
      nDist = this['nearbyDistance'];
      pxSq = nDist * nDist;
      mData = (function() {
        var l, len1, ref2, ref3, ref4, results;
        ref2 = this.markers;
        results = [];
        for (l = 0, len1 = ref2.length; l < len1; l++) {
          m = ref2[l];
          results.push({
            pt: this.llToPt((ref3 = (ref4 = m['_omsData']) != null ? ref4.usualPosition : void 0) != null ? ref3 : m.getGhostPosition()),
            willSpiderfy: false
          });
        }
        return results;
      }).call(this);
      ref2 = this.markers;
      for (i1 = l = 0, len1 = ref2.length; l < len1; i1 = ++l) {
        m1 = ref2[i1];
        if (!((m1.map != null) && m1.getVisible())) {
          continue;
        }
        m1Data = mData[i1];
        if (m1Data.willSpiderfy) {
          continue;
        }
        ref3 = this.markers;
        for (i2 = n = 0, len2 = ref3.length; n < len2; i2 = ++n) {
          m2 = ref3[i2];
          if (i2 === i1) {
            continue;
          }
          if (!((m2.map != null) && m2.getVisible())) {
            continue;
          }
          m2Data = mData[i2];
          if (i2 < i1 && !m2Data.willSpiderfy) {
            continue;
          }
          if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {
            m1Data.willSpiderfy = m2Data.willSpiderfy = true;
            break;
          }
        }
      }
      ref4 = this.markers;
      results = [];
      for (i = q = 0, len3 = ref4.length; q < len3; i = ++q) {
        m = ref4[i];
        if (mData[i].willSpiderfy) {
          results.push(m);
        }
      }
      return results;
    };

    p.makeHighlightListenerFuncs = function(marker) {
      return {
        highlight: (function(_this) {
          return function() {
            return marker['_omsData'].leg.setOptions({
              strokeColor: _this['legColors']['highlighted'][_this.map.mapTypeId],
              zIndex: _this['highlightedLegZIndex']
            });
          };
        })(this),
        unhighlight: (function(_this) {
          return function() {
            return marker['_omsData'].leg.setOptions({
              strokeColor: _this['legColors']['usual'][_this.map.mapTypeId],
              zIndex: _this['usualLegZIndex']
            });
          };
        })(this)
      };
    };

    p.spiderfy = function(markerData, nonNearbyMarkers) {
      var bodyPt, footLl, footPt, footPts, highlightListenerFuncs, leg, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;
      this.spiderfying = true;
      spMarkers = markerData.slice();
      nonspMarkers = nonNearbyMarkers.slice();
      numFeet = markerData.length;
      bodyPt = this.ptAverage((function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = markerData.length; l < len1; l++) {
          md = markerData[l];
          results.push(md.markerPt);
        }
        return results;
      })());
      footPts = numFeet >= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);
      spiderfiedMarkers = (function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = footPts.length; l < len1; l++) {
          footPt = footPts[l];
          footLl = this.ptToLl(footPt);
          nearestMarkerDatum = this.minExtract(markerData, (function(_this) {
            return function(md) {
              return _this.ptDistanceSq(md.markerPt, footPt);
            };
          })(this));
          marker = nearestMarkerDatum.marker;
          leg = new gm.Polyline({
            map: this.map,
            path: [marker.getGhostPosition(), footLl],
            strokeColor: this['legColors']['usual'][this.map.mapTypeId],
            strokeWeight: this['legWeight'],
            zIndex: this['usualLegZIndex']
          });
          marker['_omsData'] = {
            usualPosition: marker.getGhostPosition(),
            leg: leg
          };
          if (this['legColors']['highlighted'][this.map.mapTypeId] !== this['legColors']['usual'][this.map.mapTypeId]) {
            highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);
            marker['_omsData'].hightlightListeners = {
              highlight: ge.addListener(marker, 'mouseover', highlightListenerFuncs.highlight),
              unhighlight: ge.addListener(marker, 'mouseout', highlightListenerFuncs.unhighlight)
            };
          }
          marker.setGhostPosition(footLl);
          marker.setZIndex(Math.round(this['spiderfiedZIndex'] + footPt.y));
          results.push(marker);
        }
        return results;
      }).call(this);
      delete this.spiderfying;
      this.spiderfied = true;
      return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);
    };

    p['unspiderfy'] = function(markerNotToMove) {
      var l, len1, listeners, marker, nonNearbyMarkers, path, ref2, unspiderfiedMarkers;
      if (markerNotToMove == null) {
        markerNotToMove = null;
      }
      if (this.spiderfied == null) {
        return this;
      }
      this.unspiderfying = true;
      unspiderfiedMarkers = [];
      nonNearbyMarkers = [];
      ref2 = this.markers;
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        marker = ref2[l];
        if (marker['_omsData'] != null) {
          path = marker['_omsData'].leg.getPath();
          if (marker !== markerNotToMove) {
            marker.setGhostPosition(path.getArray()[0]);
          }
          marker['_omsData'].leg.setMap(null);
          marker.setZIndex(null);
          listeners = marker['_omsData'].hightlightListeners;
          if (listeners != null) {
            ge.removeListener(listeners.highlight);
            ge.removeListener(listeners.unhighlight);
          }
          delete marker['_omsData'];
          unspiderfiedMarkers.push(marker);
        } else {
          nonNearbyMarkers.push(marker);
        }
      }
      delete this.unspiderfying;
      delete this.spiderfied;
      this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);
      return this;
    };

    p.ptDistanceSq = function(pt1, pt2) {
      var dx, dy;
      dx = pt1.x - pt2.x;
      dy = pt1.y - pt2.y;
      return dx * dx + dy * dy;
    };

    p.ptAverage = function(pts) {
      var l, len1, numPts, pt, sumX, sumY;
      sumX = sumY = 0;
      for (l = 0, len1 = pts.length; l < len1; l++) {
        pt = pts[l];
        sumX += pt.x;
        sumY += pt.y;
      }
      numPts = pts.length;
      return new gm.Point(sumX / numPts, sumY / numPts);
    };

    p.llToPt = function(ll) {
      return this.projHelper.getProjection().fromLatLngToDivPixel(ll);
    };

    p.ptToLl = function(pt) {
      return this.projHelper.getProjection().fromDivPixelToLatLng(pt);
    };

    p.minExtract = function(set, func) {
      var bestIndex, bestVal, index, item, l, len1, val;
      for (index = l = 0, len1 = set.length; l < len1; index = ++l) {
        item = set[index];
        val = func(item);
        if ((typeof bestIndex === "undefined" || bestIndex === null) || val < bestVal) {
          bestVal = val;
          bestIndex = index;
        }
      }
      return set.splice(bestIndex, 1)[0];
    };

    p.arrIndexOf = function(arr, obj) {
      var i, l, len1, o;
      if (arr.indexOf != null) {
        return arr.indexOf(obj);
      }
      for (i = l = 0, len1 = arr.length; l < len1; i = ++l) {
        o = arr[i];
        if (o === obj) {
          return i;
        }
      }
      return -1;
    };

    _Class.ProjHelper = function(map) {
      return this.setMap(map);
    };

    _Class.ProjHelper.prototype = new gm.OverlayView();

    _Class.ProjHelper.prototype['draw'] = function() {};

    return _Class;

  })();

}).call(this);

//# sourceMappingURL=oms.js.map
         *@
    (function(){var e,t={}.hasOwnProperty,r=[].slice;null!=(null!=(e=this.google)?e.maps:void 0)&&(this.OverlappingMarkerSpiderfier=function(){function e(e,r){var n,s,l,o,h,a;this.map=e,null==r&&(r={});for(s in r)t.call(r,s)&&(a=r[s],this[s]=a);for(this.projHelper=new this.constructor.ProjHelper(this.map),this.initMarkerArrays(),this.listeners={},h=["click","zoom_changed","maptypeid_changed"],l=0,o=h.length;o>l;l++)n=h[l],i.addListener(this.map,n,function(e){return function(){return e.unspiderfy()}}(this)),i.addListener(this.map,n,function(e){return function(){return e.clearSpArrays()}}(this))}var i,n,s,l,o,h,a,u,p,g,f,c,d;for(p=e.prototype,g=[e,p],s=0,h=g.length;h>s;s++)d=g[s],d.VERSION="0.3.3";return n=google.maps,i=n.event,a=n.MapTypeId,c=2*Math.PI,f=[],u=[],p.keepSpiderfied=!1,p.markersWontHide=!1,p.markersWontMove=!1,p.nearbyDistance=20,p.circleSpiralSwitchover=9,p.circleFootSeparation=23,p.circleStartAngle=c/12,p.spiralFootSeparation=26,p.spiralLengthStart=11,p.spiralLengthFactor=4,p.spiderfiedZIndex=1e3,p.usualLegZIndex=10,p.highlightedLegZIndex=20,p.legWeight=1.5,p.legColors={usual:{},highlighted:{}},o=p.legColors.usual,l=p.legColors.highlighted,o[a.HYBRID]=o[a.SATELLITE]="#fff",l[a.HYBRID]=l[a.SATELLITE]="#f00",o[a.TERRAIN]=o[a.ROADMAP]="#444",l[a.TERRAIN]=l[a.ROADMAP]="#f00",p.initMarkerArrays=function(){return this.markers=[],this.markerListenerRefs=[]},p.clearSpArrays=function(){return f=[],u=[]},p.addMarker=function(e){var t;return null!=e._oms?this:(e._oms=!0,t=[i.addListener(e,"click",function(t){return function(r){return t.spiderListener(e,r)}}(this))],this.markersWontHide||t.push(i.addListener(e,"visible_changed",function(t){return function(){return t.markerChangeListener(e,!1)}}(this))),this.markersWontMove||t.push(i.addListener(e,"ghostposition_changed",function(t){return function(){return t.markerChangeListener(e,!0)}}(this))),this.markerListenerRefs.push(t),this.markers.push(e),this)},p.keepItSpiderfied=function(){return this.spiderfy(f,u)},p.markerChangeListener=function(e,t){return null==e._omsData||!t&&e.getVisible()||null!=this.spiderfying||null!=this.unspiderfying?void 0:this.unspiderfy(t?e:null)},p.getMarkers=function(){return this.markers.slice(0)},p.removeMarker=function(e){var t,r,n,s,l;if(null!=e._omsData&&this.unspiderfy(),t=this.arrIndexOf(this.markers,e),0>t)return this;for(l=this.markerListenerRefs.splice(t,1)[0],r=0,n=l.length;n>r;r++)s=l[r],i.removeListener(s);return delete e._oms,this.markers.splice(t,1),this},p.clearMarkers=function(){var e,t,r,n,s,l,o,h,a;for(this.unspiderfy(),a=this.markers,e=t=0,r=a.length;r>t;e=++t){for(o=a[e],l=this.markerListenerRefs[e],h=0,n=l.length;n>h;h++)s=l[h],i.removeListener(s);delete o._oms}return this.initMarkerArrays(),this},p.addListener=function(e,t){var r;return(null!=(r=this.listeners)[e]?r[e]:r[e]=[]).push(t),this},p.removeListener=function(e,t){var r;return r=this.arrIndexOf(this.listeners[e],t),0>r||this.listeners[e].splice(r,1),this},p.clearListeners=function(e){return this.listeners[e]=[],this},p.trigger=function(){var e,t,i,n,s,l,o,h;for(t=arguments[0],e=2<=arguments.length?r.call(arguments,1):[],o=null!=(l=this.listeners[t])?l:[],h=[],n=0,s=o.length;s>n;n++)i=o[n],h.push(i.apply(null,e));return h},p.generatePtsCircle=function(e,t){var r,i,s,l,o,h,a,u;for(s=this.circleFootSeparation*(2+e),h=s/c,i=c/e,u=[],l=o=0,a=e;a>=0?a>o:o>a;l=a>=0?++o:--o)r=this.circleStartAngle+l*i,u.push(new n.Point(t.x+h*Math.cos(r),t.y+h*Math.sin(r)));return u},p.generatePtsSpiral=function(e,t){var r,i,s,l,o,h,a;for(l=this.spiralLengthStart,r=0,a=[],i=s=0,h=e;h>=0?h>s:s>h;i=h>=0?++s:--s)r+=this.spiralFootSeparation/l+5e-4*i,o=new n.Point(t.x+l*Math.cos(r),t.y+l*Math.sin(r)),l+=c*this.spiralLengthFactor/r,a.push(o);return a},p.spiderListener=function(e,t){var r,i,n,s,l,o,h,a,u,p,g;if(o=null!=e._omsData,o&&this.keepSpiderfied||this.unspiderfy(),o||this.map.getStreetView().getVisible()||"GoogleEarthAPI"===this.map.getMapTypeId())return this.trigger("click",e,t);for(a=[],u=[],h=this.nearbyDistance,p=h*h,l=this.llToPt(e.getGhostPosition()),g=this.markers,r=0,i=g.length;i>r;r++)n=g[r],null!=n.map&&n.getVisible()&&(s=this.llToPt(n.getGhostPosition()),this.ptDistanceSq(s,l)<p?a.push({marker:n,markerPt:s}):u.push(n));return 1===a.length?this.trigger("click",e,t):this.spiderfy(a,u)},p.markersNearMarker=function(e,t){var r,i,n,s,l,o,h,a,u,p,g;if(null==t&&(t=!1),null==this.projHelper.getProjection())throw"Must wait for 'idle' event on map before calling markersNearMarker";for(h=this.nearbyDistance,a=h*h,l=this.llToPt(e.getGhostPosition()),o=[],u=this.markers,r=0,i=u.length;i>r&&(n=u[r],!(n!==e&&null!=n.map&&n.getVisible()&&(s=this.llToPt(null!=(p=null!=(g=n._omsData)?g.usualPosition:void 0)?p:n.getGhostPosition()),this.ptDistanceSq(s,l)<a&&(o.push(n),t))));r++);return o},p.markersNearAnyOtherMarker=function(){var e,t,r,i,n,s,l,o,h,a,u,p,g,f,c,d,m,k,y,v,L;if(null==this.projHelper.getProjection())throw"Must wait for 'idle' event on map before calling markersNearAnyOtherMarker";for(c=this.nearbyDistance,d=c*c,g=function(){var e,t,r,i,n,s;for(r=this.markers,s=[],e=0,t=r.length;t>e;e++)o=r[e],s.push({pt:this.llToPt(null!=(i=null!=(n=o._omsData)?n.usualPosition:void 0)?i:o.getGhostPosition()),willSpiderfy:!1});return s}.call(this),k=this.markers,t=i=0,n=k.length;n>i;t=++i)if(h=k[t],null!=h.map&&h.getVisible()&&(a=g[t],!a.willSpiderfy))for(y=this.markers,r=f=0,s=y.length;s>f;r=++f)if(u=y[r],r!==t&&null!=u.map&&u.getVisible()&&(p=g[r],(!(t>r)||p.willSpiderfy)&&this.ptDistanceSq(a.pt,p.pt)<d)){a.willSpiderfy=p.willSpiderfy=!0;break}for(v=this.markers,L=[],e=m=0,l=v.length;l>m;e=++m)o=v[e],g[e].willSpiderfy&&L.push(o);return L},p.makeHighlightListenerFuncs=function(e){return{highlight:function(t){return function(){return e._omsData.leg.setOptions({strokeColor:t.legColors.highlighted[t.map.mapTypeId],zIndex:t.highlightedLegZIndex})}}(this),unhighlight:function(t){return function(){return e._omsData.leg.setOptions({strokeColor:t.legColors.usual[t.map.mapTypeId],zIndex:t.usualLegZIndex})}}(this)}},p.spiderfy=function(e,t){var r,s,l,o,h,a,p,g,c,d,m;return this.spiderfying=!0,f=e.slice(),u=t.slice(),d=e.length,r=this.ptAverage(function(){var t,r,i;for(i=[],t=0,r=e.length;r>t;t++)g=e[t],i.push(g.markerPt);return i}()),o=d>=this.circleSpiralSwitchover?this.generatePtsSpiral(d,r).reverse():this.generatePtsCircle(d,r),m=function(){var t,r,u;for(u=[],t=0,r=o.length;r>t;t++)l=o[t],s=this.ptToLl(l),c=this.minExtract(e,function(e){return function(t){return e.ptDistanceSq(t.markerPt,l)}}(this)),p=c.marker,a=new n.Polyline({map:this.map,path:[p.getGhostPosition(),s],strokeColor:this.legColors.usual[this.map.mapTypeId],strokeWeight:this.legWeight,zIndex:this.usualLegZIndex}),p._omsData={usualPosition:p.getGhostPosition(),leg:a},this.legColors.highlighted[this.map.mapTypeId]!==this.legColors.usual[this.map.mapTypeId]&&(h=this.makeHighlightListenerFuncs(p),p._omsData.hightlightListeners={highlight:i.addListener(p,"mouseover",h.highlight),unhighlight:i.addListener(p,"mouseout",h.unhighlight)}),p.setGhostPosition(s),p.setZIndex(Math.round(this.spiderfiedZIndex+l.y)),u.push(p);return u}.call(this),delete this.spiderfying,this.spiderfied=!0,this.trigger("spiderfy",m,t)},p.unspiderfy=function(e){var t,r,n,s,l,o,h,a;if(null==e&&(e=null),null==this.spiderfied)return this;for(this.unspiderfying=!0,a=[],l=[],h=this.markers,t=0,r=h.length;r>t;t++)s=h[t],null!=s._omsData?(o=s._omsData.leg.getPath(),s!==e&&s.setGhostPosition(o.getArray()[0]),s._omsData.leg.setMap(null),s.setZIndex(null),n=s._omsData.hightlightListeners,null!=n&&(i.removeListener(n.highlight),i.removeListener(n.unhighlight)),delete s._omsData,a.push(s)):l.push(s);return delete this.unspiderfying,delete this.spiderfied,this.trigger("unspiderfy",a,l),this},p.ptDistanceSq=function(e,t){var r,i;return r=e.x-t.x,i=e.y-t.y,r*r+i*i},p.ptAverage=function(e){var t,r,i,s,l,o;for(l=o=0,t=0,r=e.length;r>t;t++)s=e[t],l+=s.x,o+=s.y;return i=e.length,new n.Point(l/i,o/i)},p.llToPt=function(e){return this.projHelper.getProjection().fromLatLngToDivPixel(e)},p.ptToLl=function(e){return this.projHelper.getProjection().fromDivPixelToLatLng(e)},p.minExtract=function(e,t){var r,i,n,s,l,o,h;for(n=l=0,o=e.length;o>l;n=++l)s=e[n],h=t(s),("undefined"==typeof r||null===r||i>h)&&(i=h,r=n);return e.splice(r,1)[0]},p.arrIndexOf=function(e,t){var r,i,n,s;if(null!=e.indexOf)return e.indexOf(t);for(r=i=0,n=e.length;n>i;r=++i)if(s=e[r],s===t)return r;return-1},e.ProjHelper=function(e){return this.setMap(e)},e.ProjHelper.prototype=new n.OverlayView,e.ProjHelper.prototype.draw=function(){},e}())}).call(this);
</script>